#!/usr/bin/env python3
"""
Summarize Dependency Report

This script reads the dependency report generated by analyze_dependencies.py
and provides a summary of the most important information.
"""

import json
import os
import sys
from collections import defaultdict
from typing import Dict, List, Set, Any, Tuple

def load_report(report_path: str) -> Dict[str, Any]:
    """
    Load the dependency report.
    
    Args:
        report_path: Path to the dependency report
        
    Returns:
        Dependency report data
    """
    try:
        with open(report_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except Exception as e:
        print(f"Error loading report: {e}")
        sys.exit(1)

def summarize_services(data: Dict[str, Any]) -> None:
    """
    Summarize services and their dependencies.
    
    Args:
        data: Dependency report data
    """
    services = data.get('services', {})
    
    print("\n=== Services Summary ===")
    print(f"Total services: {len(services)}")
    
    # Sort services by number of dependencies
    sorted_services = sorted(
        services.items(),
        key=lambda x: len(x[1].get('dependencies', [])),
        reverse=True
    )
    
    print("\nServices by dependency count:")
    for service_name, service_data in sorted_services:
        dependencies = service_data.get('dependencies', [])
        dependents = service_data.get('dependents', [])
        print(f"  {service_name}: {len(dependencies)} dependencies, {len(dependents)} dependents")

def summarize_dependencies(data: Dict[str, Any]) -> None:
    """
    Summarize service dependencies.
    
    Args:
        data: Dependency report data
    """
    service_dependencies = data.get('service_dependencies', {})
    
    print("\n=== Dependencies Summary ===")
    print(f"Total service dependencies: {sum(len(deps) for deps in service_dependencies.values())}")
    
    # Create a dependency matrix
    services = list(data.get('services', {}).keys())
    matrix = defaultdict(dict)
    
    for service in services:
        for other_service in services:
            matrix[service][other_service] = other_service in service_dependencies.get(service, [])
    
    # Print dependency matrix
    print("\nDependency Matrix (X depends on Y):")
    print("  " + " ".join(f"{s[:10]:10}" for s in services))
    for service in services:
        row = [f"{service[:10]:10}"]
        for other_service in services:
            row.append("X         " if matrix[service][other_service] else "          ")
        print(" ".join(row))

def summarize_circular_dependencies(data: Dict[str, Any]) -> None:
    """
    Summarize circular dependencies.
    
    Args:
        data: Dependency report data
    """
    circular_dependencies = data.get('circular_dependencies', [])
    
    print("\n=== Circular Dependencies ===")
    print(f"Total circular dependencies: {len(circular_dependencies)}")
    
    if circular_dependencies:
        print("\nCircular Dependencies:")
        for service1, service2 in circular_dependencies:
            print(f"  {service1} <-> {service2}")
            
            # Get the specific modules involved in the circular dependency
            service1_modules = []
            service2_modules = []
            
            module_dependencies = data.get('module_dependencies', {})
            for module, imports in module_dependencies.items():
                if service1.replace('-', '_') in module:
                    for imp in imports:
                        if service2.replace('-', '_') in imp:
                            service1_modules.append((module, imp))
                
                if service2.replace('-', '_') in module:
                    for imp in imports:
                        if service1.replace('-', '_') in imp:
                            service2_modules.append((module, imp))
            
            # Print up to 3 examples of each direction
            if service1_modules:
                print(f"    {service1} imports from {service2}:")
                for i, (module, imp) in enumerate(service1_modules[:3]):
                    print(f"      {os.path.basename(module)} imports {imp}")
                if len(service1_modules) > 3:
                    print(f"      ... and {len(service1_modules) - 3} more")
            
            if service2_modules:
                print(f"    {service2} imports from {service1}:")
                for i, (module, imp) in enumerate(service2_modules[:3]):
                    print(f"      {os.path.basename(module)} imports {imp}")
                if len(service2_modules) > 3:
                    print(f"      ... and {len(service2_modules) - 3} more")

def identify_common_dependencies(data: Dict[str, Any]) -> None:
    """
    Identify common dependencies across services.
    
    Args:
        data: Dependency report data
    """
    service_dependencies = data.get('service_dependencies', {})
    
    # Count how many services depend on each service
    dependency_counts = defaultdict(int)
    for service, dependencies in service_dependencies.items():
        for dep in dependencies:
            dependency_counts[dep] += 1
    
    # Sort by count
    sorted_deps = sorted(
        dependency_counts.items(),
        key=lambda x: x[1],
        reverse=True
    )
    
    print("\n=== Common Dependencies ===")
    print("Services that are depended on by multiple other services:")
    for dep, count in sorted_deps:
        if count > 1:
            dependents = [s for s, deps in service_dependencies.items() if dep in deps]
            print(f"  {dep}: {count} dependents ({', '.join(dependents[:5])}{'...' if len(dependents) > 5 else ''})")

def suggest_improvements(data: Dict[str, Any]) -> None:
    """
    Suggest improvements based on the dependency analysis.
    
    Args:
        data: Dependency report data
    """
    circular_dependencies = data.get('circular_dependencies', [])
    service_dependencies = data.get('service_dependencies', {})
    
    print("\n=== Suggested Improvements ===")
    
    # Suggest fixing circular dependencies
    if circular_dependencies:
        print("\n1. Fix Circular Dependencies:")
        for service1, service2 in circular_dependencies:
            print(f"  - Resolve circular dependency between {service1} and {service2}")
            print(f"    Consider using an interface-based adapter pattern or event-based communication")
    
    # Identify services with too many dependencies
    high_dependency_services = []
    for service, dependencies in service_dependencies.items():
        if len(dependencies) > 3:  # Arbitrary threshold
            high_dependency_services.append((service, len(dependencies)))
    
    if high_dependency_services:
        print("\n2. Reduce High Dependency Services:")
        for service, count in sorted(high_dependency_services, key=lambda x: x[1], reverse=True):
            print(f"  - {service} depends on {count} other services")
            print(f"    Consider refactoring to reduce dependencies or use more abstraction")
    
    # Identify potential shared libraries
    dependency_counts = defaultdict(int)
    for service, dependencies in service_dependencies.items():
        for dep in dependencies:
            dependency_counts[dep] += 1
    
    common_deps = [dep for dep, count in dependency_counts.items() if count > 2]  # Arbitrary threshold
    
    if common_deps:
        print("\n3. Consider Shared Libraries:")
        print("  The following services are widely used and might benefit from being treated as shared libraries:")
        for dep in common_deps:
            print(f"  - {dep}")

def main():
    """Main entry point."""
    import argparse
    
    parser = argparse.ArgumentParser(description="Summarize dependency report")
    parser.add_argument(
        "--report-path",
        default="tools/output/dependency-report.json",
        help="Path to the dependency report"
    )
    args = parser.parse_args()
    
    # Load report
    data = load_report(args.report_path)
    
    # Summarize report
    summarize_services(data)
    summarize_dependencies(data)
    summarize_circular_dependencies(data)
    identify_common_dependencies(data)
    suggest_improvements(data)

if __name__ == "__main__":
    main()
