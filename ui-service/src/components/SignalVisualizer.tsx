// filepath: d:\MD\forex_trading_platform\ui-service\src\components\SignalVisualizer.tsx
/**
 * Signal Visualizer Component
 *
 * Displays trading signals generated by strategies or models.
 * Should visualize aspects like:
 * - Signal type (Entry Long, Exit Long, Entry Short, Exit Short)
 * - Confidence level
 * - Associated strategy/model ID
 * - Timestamp
 * - Target symbol/timeframe
 * - Potentially overlay signals on a chart (integration with charting library needed)
 */

import React, { useState, useEffect } from 'react';
// import Chart from './charts/SomeChartLibraryWrapper'; // Example chart integration

// --- Mock Data --- 
const mockSignals = [
  {
    id: 'sig-001',
    timestamp: new Date(Date.now() - 60 * 1000).toISOString(), // 1 min ago
    strategyId: 'strat_A',
    symbol: 'EURUSD',
    timeframe: 'H1',
    type: 'Entry Long',
    confidence: 0.75,
    details: { priceTarget: 1.0900, stopLoss: 1.0820 }
  },
  {
    id: 'sig-002',
    timestamp: new Date(Date.now() - 120 * 1000).toISOString(), // 2 mins ago
    strategyId: 'strat_B',
    symbol: 'GBPUSD',
    timeframe: 'M15',
    type: 'Entry Short',
    confidence: 0.60,
    details: { indicator: 'MACD Crossover' }
  },
  {
    id: 'sig-003',
    timestamp: new Date(Date.now() - 300 * 1000).toISOString(), // 5 mins ago
    strategyId: 'strat_A',
    symbol: 'EURUSD',
    timeframe: 'H1',
    type: 'Exit Short', // Example exit signal
    confidence: 0.90,
    details: { reason: 'Take Profit Hit' }
  },
];

interface Signal {
  id: string;
  timestamp: string;
  strategyId: string;
  symbol: string;
  timeframe: string;
  type: 'Entry Long' | 'Entry Short' | 'Exit Long' | 'Exit Short' | string; // Allow other types
  confidence: number; // e.g., 0 to 1
  details?: Record<string, any>;
}

interface SignalVisualizerProps {
  // Props to potentially filter signals, e.g., by symbol or strategy
  symbolFilter?: string;
  strategyFilter?: string;
}

const SignalVisualizer: React.FC<SignalVisualizerProps> = ({ symbolFilter, strategyFilter }) => {
  const [signals, setSignals] = useState<Signal[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  // Implement real-time data fetching for signals using WebSockets
  useEffect(() => {
    setIsLoading(true);
    
    // Initial data fetch via REST API
    const fetchInitialSignals = async () => {
      try {
        // Build query parameters for filtering
        const queryParams = new URLSearchParams();
        if (symbolFilter) queryParams.append('symbol', symbolFilter);
        if (strategyFilter) queryParams.append('strategy', strategyFilter);
        
        // In a real implementation, this would be an API call
        // const response = await fetch(`/api/signals?${queryParams}`);
        // const data = await response.json();
        // setSignals(data);
        
        // For now, use filtered mock data
        const filteredMockSignals = mockSignals.filter(sig => 
          (!symbolFilter || sig.symbol === symbolFilter) &&
          (!strategyFilter || sig.strategyId === strategyFilter)
        );
        
        setSignals(filteredMockSignals);
        setIsLoading(false);
      } catch (err) {
        console.error('Error fetching signals:', err);
        setError('Failed to load signals');
        setIsLoading(false);
      }
    };
    
    fetchInitialSignals();
    
    // WebSocket connection for real-time updates
    const wsEndpoint = `ws://${window.location.host}/ws/signals`;
    const ws = new WebSocket(wsEndpoint);
    
    ws.onopen = () => {
      console.log('WebSocket connection established');
      // Send subscription message with filters
      const subscription = {
        action: 'subscribe',
        channel: 'signals',
        filters: {
          symbol: symbolFilter || null,
          strategy: strategyFilter || null
        }
      };
      ws.send(JSON.stringify(subscription));
    };
    
    ws.onmessage = (event) => {
      try {
        const signalData = JSON.parse(event.data);
        // Check if the signal matches our filters
        if ((!symbolFilter || signalData.symbol === symbolFilter) &&
            (!strategyFilter || signalData.strategyId === strategyFilter)) {
          setSignals(prev => [signalData, ...prev].slice(0, 50)); // Add to top, limit size
        }
      } catch (err) {
        console.error('Error processing signal:', err);
      }
    };
    
    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
      setError('WebSocket connection error');
      
      // Fallback to polling if WebSocket fails
      const pollingInterval = setInterval(() => {
        fetchInitialSignals();
      }, 30000); // Poll every 30 seconds as fallback
      
      return () => clearInterval(pollingInterval);
    };

    return () => {
      // Close WebSocket connection on cleanup
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.close();
        console.log('WebSocket connection closed');
      }
    };
  }, [symbolFilter, strategyFilter]); // Refetch/filter if props change

  if (isLoading) {
    return <div>Loading signals...</div>;
  }

  if (error) {
    return <div style={{ color: 'red' }}>Error: {error}</div>;
  }
  // Implement a more sophisticated visualization with table and visual indicators
  return (
    <div className="signal-visualizer">
      <div className="signal-header">
        <h3>Trading Signals</h3>
        <div className="signal-filters">
          <span>Filters: </span>
          {symbolFilter && <span className="filter-tag">Symbol: {symbolFilter}</span>}
          {strategyFilter && <span className="filter-tag">Strategy: {strategyFilter}</span>}
        </div>
      </div>
      
      {signals.length === 0 ? (
        <p className="no-signals">No signals matching criteria.</p>
      ) : (
        <div className="signals-table-container">
          <table className="signals-table">
            <thead>
              <tr>
                <th>Time</th>
                <th>Symbol</th>
                <th>Strategy</th>
                <th>Signal</th>
                <th>Timeframe</th>
                <th>Confidence</th>
                <th>Status</th>
              </tr>
            </thead>
            <tbody>
              {signals.map(signal => (
                <tr key={signal.id} className={`signal-row ${signal.type.toLowerCase().includes('long') ? 'buy-signal' : 'sell-signal'}`}>
                  <td>{new Date(signal.timestamp).toLocaleTimeString()}</td>
                  <td>{signal.symbol}</td>
                  <td>{signal.strategyId}</td>
                  <td className={`signal-type ${signal.type.toLowerCase().includes('long') ? 'buy' : 'sell'}`}>
                    {signal.type}
                    {signal.type.toLowerCase().includes('long') ? 
                      <span className="signal-icon buy">↑</span> : 
                      <span className="signal-icon sell">↓</span>}
                  </td>
                  <td>{signal.timeframe}</td>
                  <td>
                    <div className="confidence-bar-container">
                      <div 
                        className="confidence-bar" 
                        style={{ 
                          width: `${signal.confidence * 100}%`,
                          backgroundColor: signal.confidence > 0.6 ? '#4caf50' : 
                                          signal.confidence > 0.4 ? '#ff9800' : '#f44336'
                        }}
                      />
                      <span className="confidence-text">{Math.round(signal.confidence * 100)}%</span>
                    </div>
                  </td>
                  <td>
                    <span className="signal-status">
                      {signal.details?.executed ? 'Executed' : 'Pending'}
                    </span>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}
      
      <div className="signal-stats">
        <div className="stat-item">
          <span className="stat-label">Total Signals:</span>
          <span className="stat-value">{signals.length}</span>
        </div>
        <div className="stat-item">
          <span className="stat-label">Buy Signals:</span>
          <span className="stat-value">{signals.filter(s => s.type.toLowerCase().includes('long')).length}</span>
        </div>
        <div className="stat-item">
          <span className="stat-label">Sell Signals:</span>
          <span className="stat-value">{signals.filter(s => s.type.toLowerCase().includes('short')).length}</span>
        </div>
        <div className="stat-item">
          <span className="stat-label">Avg. Confidence:</span>
          <span className="stat-value">
            {signals.length > 0 ? 
              `${Math.round(signals.reduce((sum, s) => sum + s.confidence, 0) / signals.length * 100)}%` : 
              'N/A'}
          </span>
        </div>
      </div>
    </div>
  );
};

export default SignalVisualizer;
