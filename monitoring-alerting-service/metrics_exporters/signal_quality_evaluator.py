"""
Signal Quality Evaluation Framework

This module provides functionality for evaluating the quality of signals generated by trading tools.
It uses various metrics to assess signal quality across different market regimes and timeframes.
"""
import numpy as np
import pandas as pd
from typing import Dict, List, Any, Tuple
from datetime import datetime, timedelta
import logging
logging.basicConfig(level=logging.INFO, format=
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


from monitoring_alerting_service.error.exceptions_bridge import (
    with_exception_handling,
    async_with_exception_handling,
    ForexTradingPlatformError,
    ServiceError,
    DataError,
    ValidationError
)

class SignalQualityEvaluator:
    """
    Evaluates the quality of trading signals across different market regimes and timeframes.
    
    This class uses multiple metrics to provide a comprehensive assessment of signal quality:
    - Signal accuracy (correlation with subsequent price movement)
    - Signal timeliness (how early/late signals are generated)
    - Signal consistency (variance in signal performance)
    - Regime-specific performance (how signals perform in different market conditions)
    """

    def __init__(self):
        """Initialize the signal quality evaluator"""
        self.logger = logging.getLogger(__name__)

    def evaluate_signal_quality(self, signals: pd.DataFrame, outcomes: pd.
        DataFrame, market_regimes: pd.DataFrame) ->Dict[str, Any]:
        """
        Evaluate the quality of signals based on various metrics.
        
        Args:
            signals: DataFrame with signal data (timestamps, tool_id, signal_type, strength, etc.)
            outcomes: DataFrame with trade outcomes (entry_time, exit_time, pnl, etc.)
            market_regimes: DataFrame with market regime classifications by time period
            
        Returns:
            Dictionary with quality metrics
        """
        self.logger.info(f'Evaluating quality of {len(signals)} signals')
        matched_data = self._match_signals_to_outcomes(signals, outcomes)
        with_regimes = self._add_regime_data(matched_data, market_regimes)
        quality_metrics = self._calculate_quality_metrics(with_regimes)
        regime_metrics = self._calculate_regime_specific_metrics(with_regimes)
        results = {'overall_metrics': quality_metrics, 'regime_metrics':
            regime_metrics}
        return results

    def _match_signals_to_outcomes(self, signals: pd.DataFrame, outcomes:
        pd.DataFrame) ->pd.DataFrame:
        """Match signals to their corresponding trading outcomes"""
        self.logger.debug('Matching signals to outcomes')
        merged = pd.merge_asof(signals.sort_values('timestamp'), outcomes.
            sort_values('entry_time'), left_on='timestamp', right_on=
            'entry_time', direction='forward', tolerance=pd.Timedelta('1h'))
        return merged

    def _add_regime_data(self, data: pd.DataFrame, regimes: pd.DataFrame
        ) ->pd.DataFrame:
        """Add market regime classification to the signal-outcome data"""
        self.logger.debug('Adding market regime data')
        if not isinstance(regimes.index, pd.DatetimeIndex):
            if 'timestamp' in regimes.columns:
                regimes = regimes.set_index('timestamp')
            else:
                raise ValueError(
                    'Market regimes DataFrame must have a timestamp column or datetime index'
                    )
        result = data.copy()
        result['market_regime'] = result['timestamp'].apply(lambda ts: self
            ._get_regime_at_time(ts, regimes))
        return result

    @with_exception_handling
    def _get_regime_at_time(self, timestamp: pd.Timestamp, regimes: pd.
        DataFrame) ->str:
        """Determine market regime at a specific timestamp"""
        try:
            closest_idx = regimes.index.asof(timestamp)
            if closest_idx is not None:
                return regimes.loc[closest_idx, 'regime']
        except:
            pass
        return 'unknown'

    def _calculate_quality_metrics(self, data: pd.DataFrame) ->Dict[str, float
        ]:
        """Calculate overall signal quality metrics"""
        self.logger.debug('Calculating overall signal quality metrics')
        metrics = {}
        if len(data) == 0:
            self.logger.warning(
                'No matched signal-outcome data available for quality metrics calculation'
                )
            return {'accuracy_score': 0.0, 'timeliness_score': 0.0,
                'consistency_score': 0.0, 'overall_quality_score': 0.0}
        if ('signal_direction' in data.columns and 'price_direction' in
            data.columns):
            correct_directions = (data['signal_direction'] == data[
                'price_direction']).sum()
            metrics['accuracy_score'] = correct_directions / len(data)
        else:
            profitable_trades = (data['pnl'] > 0).sum()
            metrics['accuracy_score'] = profitable_trades / len(data)
        if 'signal_to_movement_time' in data.columns:
            max_acceptable_delay = pd.Timedelta('1h')
            timeliness_values = data['signal_to_movement_time'].apply(lambda
                x: max(0, 1 - x / max_acceptable_delay))
            metrics['timeliness_score'] = timeliness_values.mean()
        else:
            metrics['timeliness_score'] = 0.5
        if 'pnl' in data.columns:
            if 'position_size' in data.columns and (data['position_size'] > 0
                ).all():
                normalized_pnl = data['pnl'] / data['position_size']
            else:
                normalized_pnl = data['pnl']
            mean_pnl = normalized_pnl.mean()
            std_pnl = normalized_pnl.std()
            if mean_pnl > 0:
                cv = std_pnl / abs(mean_pnl) if mean_pnl != 0 else float('inf')
                metrics['consistency_score'] = max(0, min(1, 1 - min(cv, 1)))
            else:
                metrics['consistency_score'] = 0
        else:
            metrics['consistency_score'] = 0.5
        metrics['overall_quality_score'] = 0.5 * metrics['accuracy_score'
            ] + 0.3 * metrics['timeliness_score'] + 0.2 * metrics[
            'consistency_score']
        return metrics

    def _calculate_regime_specific_metrics(self, data: pd.DataFrame) ->Dict[
        str, Dict[str, float]]:
        """Calculate signal quality metrics specific to each market regime"""
        self.logger.debug('Calculating regime-specific quality metrics')
        regime_metrics = {}
        regimes = data['market_regime'].unique()
        for regime in regimes:
            if regime == 'unknown':
                continue
            regime_data = data[data['market_regime'] == regime]
            regime_metrics[regime] = self._calculate_quality_metrics(
                regime_data)
        return regime_metrics
