"""
Market Regime Identifier Metrics Exporter

This module identifies market regimes and exports metrics for use in the Tool Effectiveness Dashboard.
It classifies market conditions into different regimes such as trending, ranging, volatile, etc.
"""
import numpy as np
import pandas as pd
from typing import Dict, List, Any, Optional
from enum import Enum
import logging
from datetime import datetime, timedelta
from prometheus_client import Gauge, Counter, start_http_server
import requests
import json
logging.basicConfig(level=logging.INFO, format=
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


from core.exceptions_bridge_1 import (
    with_exception_handling,
    async_with_exception_handling,
    ForexTradingPlatformError,
    ServiceError,
    DataError,
    ValidationError
)

class MarketRegimeType(str, Enum):
    """Enumeration of different market regime types"""
    TRENDING_UP = 'trending_up'
    TRENDING_DOWN = 'trending_down'
    RANGING = 'ranging'
    VOLATILE = 'volatile'
    BREAKOUT = 'breakout'
    REVERSAL = 'reversal'
    UNKNOWN = 'unknown'


class MarketRegimeIdentifier:
    """
    Identifies market regimes based on price action analysis and exports metrics.
    
    This class provides methods to classify market conditions into different regimes
    which helps in evaluating how tools perform under different market conditions.
    """

    def __init__(self, lookback_periods: Dict[str, int]=None, thresholds:
        Dict[str, float]=None):
        """
        Initialize market regime identifier with configurable parameters
        
        Args:
            lookback_periods: Dictionary with lookback periods for different calculations
            thresholds: Dictionary with thresholds for regime classification
        """
        self.lookback_periods = lookback_periods or {'trend': 20,
            'volatility': 14, 'range': 10, 'breakout': 5}
        self.thresholds = thresholds or {'trend_strength': 25.0,
            'volatility_high': 1.5, 'range_bounds': 0.3,
            'breakout_strength': 2.0}
        self.regime_gauge = Gauge('market_regime', 'Current market regime',
            ['instrument', 'timeframe', 'regime'])
        self.regime_duration_gauge = Gauge('market_regime_duration',
            'Duration of current market regime in hours', ['instrument',
            'timeframe', 'regime'])
        self.regime_transitions = Counter('market_regime_transitions_total',
            'Number of transitions between market regimes', ['instrument',
            'timeframe', 'from_regime', 'to_regime'])
        self.tool_effectiveness_gauge = Gauge('tool_effectiveness_by_regime',
            'Success rate of tools under different market regimes', [
            'tool_name', 'instrument', 'timeframe', 'regime'])
        self.win_rate_gauge = Gauge('tool_win_rate',
            'Win rate percentage for trading tools', ['tool_name',
            'instrument', 'timeframe'])
        self.signal_count_gauge = Gauge('tool_signal_count',
            'Number of signals generated by trading tools', ['tool_name',
            'instrument', 'timeframe', 'signal_type'])
        self.current_regimes = {}

    def identify_regime(self, instrument: str, timeframe: str, ohlcv_data:
        pd.DataFrame) ->MarketRegimeType:
        """
        Identify the current market regime based on price action analysis
        
        Args:
            instrument: The trading instrument (e.g., "EUR/USD")
            timeframe: The timeframe of the data (e.g., "1h", "4h", "1d")
            ohlcv_data: DataFrame with OHLCV (Open, High, Low, Close, Volume) data
            
        Returns:
            MarketRegimeType: The identified market regime
        """
        if len(ohlcv_data) < max(self.lookback_periods.values()):
            logger.warning(
                f'Not enough data to identify regime for {instrument} {timeframe}'
                )
            return MarketRegimeType.UNKNOWN
        regime = self._calculate_regime(ohlcv_data)
        self._update_metrics(instrument, timeframe, regime)
        return regime

    def _calculate_regime(self, df: pd.DataFrame) ->MarketRegimeType:
        """Calculate market regime based on technical indicators"""
        trend_strength = self._calculate_adx(df, self.lookback_periods['trend']
            )
        volatility = self._calculate_atr_percentage(df, self.
            lookback_periods['volatility'])
        avg_volatility = volatility.rolling(window=self.lookback_periods[
            'volatility']).mean().iloc[-1]
        current_volatility = volatility.iloc[-1]
        close = df['close'].values
        price_change = (close[-1] / close[-self.lookback_periods['trend']] - 1
            ) * 100
        is_breakout = self._detect_breakout(df, self.lookback_periods[
            'breakout'])
        is_reversal = self._detect_reversal(df, self.lookback_periods['trend'])
        if is_reversal:
            regime = MarketRegimeType.REVERSAL
        elif is_breakout:
            regime = MarketRegimeType.BREAKOUT
        elif trend_strength > self.thresholds['trend_strength']:
            if price_change > 0:
                regime = MarketRegimeType.TRENDING_UP
            else:
                regime = MarketRegimeType.TRENDING_DOWN
        elif current_volatility > avg_volatility * self.thresholds[
            'volatility_high']:
            regime = MarketRegimeType.VOLATILE
        elif abs(price_change) < self.thresholds['range_bounds']:
            regime = MarketRegimeType.RANGING
        else:
            regime = MarketRegimeType.UNKNOWN
        return regime

    def _calculate_adx(self, df: pd.DataFrame, period: int) ->float:
        """Calculate Average Directional Index (ADX) for measuring trend strength"""
        high = df['high'].values
        low = df['low'].values
        close = df['close'].values
        tr1 = np.abs(high[1:] - low[1:])
        tr2 = np.abs(high[1:] - close[:-1])
        tr3 = np.abs(low[1:] - close[:-1])
        tr = np.maximum(tr1, np.maximum(tr2, tr3))
        plus_dm = np.zeros_like(high[1:])
        minus_dm = np.zeros_like(high[1:])
        up_move = high[1:] - high[:-1]
        down_move = low[:-1] - low[1:]
        plus_dm = np.where((up_move > down_move) & (up_move > 0), up_move, 0)
        minus_dm = np.where((down_move > up_move) & (down_move > 0),
            down_move, 0)
        df_adx = pd.DataFrame({'TR': np.append(np.nan, tr), '+DM': np.
            append(np.nan, plus_dm), '-DM': np.append(np.nan, minus_dm)})
        df_adx['TR' + str(period)] = df_adx['TR'].rolling(window=period).sum()
        df_adx['+DM' + str(period)] = df_adx['+DM'].rolling(window=period).sum(
            )
        df_adx['-DM' + str(period)] = df_adx['-DM'].rolling(window=period).sum(
            )
        df_adx['+DI' + str(period)] = 100 * df_adx['+DM' + str(period)
            ] / df_adx['TR' + str(period)]
        df_adx['-DI' + str(period)] = 100 * df_adx['-DM' + str(period)
            ] / df_adx['TR' + str(period)]
        df_adx['DX'] = 100 * np.abs((df_adx['+DI' + str(period)] - df_adx[
            '-DI' + str(period)]) / (df_adx['+DI' + str(period)] + df_adx[
            '-DI' + str(period)]))
        df_adx['ADX'] = df_adx['DX'].rolling(window=period).mean()
        return df_adx['ADX'].iloc[-1]

    def _calculate_atr_percentage(self, df: pd.DataFrame, period: int
        ) ->pd.Series:
        """Calculate Average True Range (ATR) as percentage of price"""
        high = df['high'].values
        low = df['low'].values
        close = np.roll(df['close'].values, 1)
        close[0] = df['close'].values[0]
        tr1 = high - low
        tr2 = np.abs(high - close)
        tr3 = np.abs(low - close)
        tr = np.maximum(tr1, np.maximum(tr2, tr3))
        atr_pct = pd.Series(tr / df['close'].values * 100)
        return atr_pct

    def _detect_breakout(self, df: pd.DataFrame, period: int) ->bool:
        """Detect if a breakout has occurred"""
        recent_high = df['high'].rolling(window=period).max().iloc[-2]
        recent_low = df['low'].rolling(window=period).min().iloc[-2]
        current_close = df['close'].iloc[-1]
        previous_close = df['close'].iloc[-2]
        avg_range = (df['high'] - df['low']).rolling(window=period).mean(
            ).iloc[-2]
        breakout_threshold = avg_range * self.thresholds['breakout_strength']
        is_upward_breakout = (current_close > recent_high and current_close -
            previous_close > breakout_threshold)
        is_downward_breakout = (current_close < recent_low and 
            previous_close - current_close > breakout_threshold)
        return is_upward_breakout or is_downward_breakout

    def _detect_reversal(self, df: pd.DataFrame, period: int) ->bool:
        """Detect if a price reversal has occurred"""
        short_ma = df['close'].rolling(window=5).mean()
        long_ma = df['close'].rolling(window=period).mean()
        previous_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
        current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
        return previous_diff * current_diff < 0

    def _update_metrics(self, instrument: str, timeframe: str, regime:
        MarketRegimeType):
        """Update Prometheus metrics for the identified regime"""
        for r in MarketRegimeType:
            self.regime_gauge.labels(instrument=instrument, timeframe=
                timeframe, regime=r).set(0)
        self.regime_gauge.labels(instrument=instrument, timeframe=timeframe,
            regime=regime).set(1)
        key = instrument, timeframe
        now = datetime.now()
        if key in self.current_regimes:
            last_regime, start_time = self.current_regimes[key]
            if last_regime != regime:
                self.regime_transitions.labels(instrument=instrument,
                    timeframe=timeframe, from_regime=last_regime, to_regime
                    =regime).inc()
                self.current_regimes[key] = regime, now
            else:
                duration_hours = (now - start_time).total_seconds() / 3600.0
                self.regime_duration_gauge.labels(instrument=instrument,
                    timeframe=timeframe, regime=regime).set(duration_hours)
        else:
            self.current_regimes[key] = regime, now

    def start_metrics_server(self, port: int=8000):
        """Start the Prometheus metrics HTTP server"""
        start_http_server(port)
        logger.info(f'Market regime metrics server started on port {port}')

    def export_metrics_for_tool_effectiveness(self, tool_name: str,
        instrument: str, timeframe: str, success_rate: float, regime:
        MarketRegimeType):
        """
        Export tool effectiveness metrics by market regime
        
        Args:
            tool_name: Name of the analysis tool
            instrument: Trading instrument
            timeframe: Data timeframe
            success_rate: Tool's success rate (0-100)
            regime: Market regime during which the tool was used
        """
        self.tool_effectiveness_gauge.labels(tool_name=tool_name,
            instrument=instrument, timeframe=timeframe, regime=regime).set(
            success_rate)

    def export_win_rate(self, tool_name: str, instrument: str, timeframe:
        str, win_rate: float):
        """
        Export win rate metrics for a tool
        
        Args:
            tool_name: Name of the analysis tool
            instrument: Trading instrument
            timeframe: Data timeframe
            win_rate: Win rate percentage (0-100)
        """
        self.win_rate_gauge.labels(tool_name=tool_name, instrument=
            instrument, timeframe=timeframe).set(win_rate)

    def export_signal_count(self, tool_name: str, instrument: str,
        timeframe: str, signal_type: str, count: int):
        """
        Export signal count metrics for a tool
        
        Args:
            tool_name: Name of the analysis tool
            instrument: Trading instrument
            timeframe: Data timeframe
            signal_type: Type of signal (e.g., "buy", "sell", "neutral")
            count: Number of signals
        """
        self.signal_count_gauge.labels(tool_name=tool_name, instrument=
            instrument, timeframe=timeframe, signal_type=signal_type).set(count
            )

    @with_exception_handling
    def fetch_effectiveness_data_from_api(self, api_url: str) ->List[Dict[
        str, Any]]:
        """
        Fetch effectiveness data from the analysis engine API
        
        Args:
            api_url: URL of the analysis engine API
            
        Returns:
            List of effectiveness data records
        """
        try:
            response = requests.get(
                f'{api_url}/api/v1/tool-effectiveness/summary', params={
                'last_n_days': 30})
            if response.status_code == 200:
                data = response.json()
                logger.info(
                    f"Successfully fetched {len(data.get('records', []))} effectiveness records"
                    )
                return data.get('records', [])
            else:
                logger.error(
                    f'Failed to fetch effectiveness data: {response.text}')
                return []
        except Exception as e:
            logger.error(f'Error fetching effectiveness data: {e}')
            return []

    @with_exception_handling
    def process_effectiveness_data(self, records: List[Dict[str, Any]]):
        """
        Process effectiveness data and export metrics
        
        Args:
            records: List of effectiveness data records
        """
        if not records:
            logger.warning('No effectiveness records to process')
            return
        grouped_data = {}
        for record in records:
            tool_name = record.get('analyzer_name', 'unknown')
            instrument = record.get('instrument', 'unknown')
            timeframe = record.get('timeframe', 'unknown')
            regime = record.get('market_regime', 'unknown')
            accuracy = record.get('accuracy', 0) * 100
            key = tool_name, instrument, timeframe
            regime_key = *key, regime
            if key not in grouped_data:
                grouped_data[key] = {'total_records': 0, 'success_count': 0,
                    'regimes': {}}
            grouped_data[key]['total_records'] += 1
            grouped_data[key]['success_count'] += 1 if accuracy >= 50 else 0
            if regime not in grouped_data[key]['regimes']:
                grouped_data[key]['regimes'][regime] = {'total': 0,
                    'success': 0}
            grouped_data[key]['regimes'][regime]['total'] += 1
            grouped_data[key]['regimes'][regime]['success'
                ] += 1 if accuracy >= 50 else 0
        for key, data in grouped_data.items():
            tool_name, instrument, timeframe = key
            win_rate = data['success_count'] / data['total_records'
                ] * 100 if data['total_records'] > 0 else 0
            self.export_win_rate(tool_name, instrument, timeframe, win_rate)
            for regime, regime_data in data['regimes'].items():
                regime_win_rate = regime_data['success'] / regime_data['total'
                    ] * 100 if regime_data['total'] > 0 else 0
                try:
                    regime_enum = MarketRegimeType(regime)
                except ValueError:
                    regime_enum = MarketRegimeType.UNKNOWN
                self.export_metrics_for_tool_effectiveness(tool_name,
                    instrument, timeframe, regime_win_rate, regime_enum)


@with_exception_handling
def main():
    """Main entry point for the market regime identifier metrics exporter"""
    logging.info('Starting market regime identifier metrics exporter')
    identifier = MarketRegimeIdentifier()
    identifier.start_metrics_server(port=8080)
    analysis_engine_api_url = 'http://localhost:8003'
    while True:
        try:
            records = identifier.fetch_effectiveness_data_from_api(
                analysis_engine_api_url)
            identifier.process_effectiveness_data(records)
            import time
            time.sleep(300)
        except Exception as e:
            logger.error(f'Error in main loop: {e}')
            time.sleep(60)


if __name__ == '__main__':
    main()
